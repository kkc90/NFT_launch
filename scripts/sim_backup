const { ethers } = require("hardhat");
const hre = require("hardhat");

// let mint_price = "1.0";
let contract_name = "DutchAuction";
let ts;

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function randn_bm(min, max, skew) {
    let u = 0, v = 0;
    while (u === 0) u = Math.random() //Converting [0,1) to (0,1)
    while (v === 0) v = Math.random()
    let num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v)

    num = num / 10.0 + 0.5 // Translate to 0 -> 1
    if (num > 1 || num < 0)
        num = randn_bm(min, max, skew) // resample between 0 and 1 if out of range

    else {
        num = Math.pow(num, skew) // Skew
        num *= max - min // Stretch to fill range
        num += min // offset to min
    }
    return num
}

async function virtualUser(provider, contract, eth_account) {
    let address = await eth_account.getAddress();
    console.log("Account:", address);
    // console.log(await ethers.Signer.isSigner(eth_account));
    const signer = provider.getSigner(address);
    // console.log(signer)

    // const bytecode = await provider.getCode(contract.address);
    // console.log("Bytecode:", bytecode);
    // const contract_user = new ethers.ContractFactory(abi, bytecode, eth_account);
    // console.log(contract_user);

    let contract_user = await ethers.getContractAt(contract_name, contract.address);
    let mintPrice = await contract_user.calculatePrice();
    console.log("NFT minting price:", mintPrice);

    let contractWithSigner = contract_user.connect(signer);
    // console.log(contractWithSigner);

    // console.log("Block number (latest): ", await provider.getBlockNumber())
    let estimatedGas = await provider.getFeeData();
    let baseFeePerGas = estimatedGas.lastBaseFeePerGas;
    console.log("lastBaseFeePerGas:", baseFeePerGas);

    balance = await provider.getBalance(address);
    console.log("Balance: ", balance);
    try {
        tx = await contractWithSigner.estimateGas.mintNFT(1, { value: mintPrice });
        console.log("Estimated gas for mint tx: ", tx);
        txfee = ethers.utils.formatUnits(tx * baseFeePerGas, "ether")
        console.log("Tx fee (ETH): ", txfee);
        cost = mintPrice.add(ethers.utils.parseEther(txfee));
        console.log("Tx fee + Mint price (ETH): ", cost);    
    } catch(error) {
        console.log("Error: ", error);
    }

    if (balance.gte(cost)) {
        mc = await contractWithSigner.mintCount();
        console.log("Mint count: ", mc);
        if (mc.lt(ts)) {
            try {
                tx_response = await contractWithSigner.mintNFT(1, { gasLimit: tx, value: mintPrice })
                console.log("Receipt: ", tx_response);
            } catch (error) {
                console.log("Error: ", error);
            }
        }
    }
}


async function main() {
    // const provider = await ethers.providers.Provider;
    // console.log("Ethereum provider:", provider.);
    // let provider = new ethers.providers.Web3Provider(network.provider);
    let provider;
    if (network.config.url !== undefined) {
        provider = new ethers.providers.JsonRpcProvider(
            network.config.url
        );
    } else {
        // if network.config.url is undefined, then this is the hardhat network
        provider = hre.ethers.provider;
        // provider = new ethers.providers.Web3Provider(network.provider);
    }

    /***
     * Deploy a smart contract for NFT
     */
    const DUTCH = await hre.ethers.getContractFactory("DutchAuction");
    let dutch = await DUTCH.deploy();

    await dutch.deployed();
    console.log(
        `DutchAuction deployed to ${dutch.address}`
    );


    /*** 
     * Set up an account of deploying smart contract and distributing ETH to others
     */
    const [deployer] = await ethers.getSigners();
    console.log("Deploying contracts with the account:", deployer.address);
    console.log("Account balance:", (await deployer.getBalance()).toString());

    /*** 
     * Create other accounts who want to get NFTs
     */
    let eth_accounts = [];
    let eth_address_accounts = [];
    let eth_amounts = [];
    for (let i = 0; i < 100; i++) {
        let wallet = await ethers.Wallet.createRandom();
        // let walletWithProvider = wallet.connect(provider);
        eth_address_accounts.push(await wallet.getAddress())
        // console.log(eth_address_accouts[i]);
        await provider.send("hardhat_impersonateAccount", [eth_address_accounts[i]]);
        const account = provider.getSigner(eth_address_accounts[i]);
        eth_accounts.push(account);

        eth_amounts.push(randn_bm(1, 15, 1).toString())

        await deployer.sendTransaction({
            to: eth_address_accounts[i],
            value: ethers.utils.parseEther(eth_amounts[i])
        });
    }

    // for (let i = 0; i < 100; i++) {
    //     console.log("Account %d balance: %s", i, (await provider.getBalance(eth_address_accouts[i])));
    // }

    // const [deployer] = await ethers.getSigners();
    console.log("Ethereum Accounts:", eth_address_accounts);
    console.log("Accounts ETH amounts:", eth_amounts);

    /***
     * Deploy a smart contract for NFT
     */
    await dutch.startAuction();
    await delay(7000);
    isActive = await dutch.isAuctionActive();
    if (isActive != true) {
        console.log("Activation failed");
        process.exit(1);
    }

    stime = await dutch.startTime();
    console.log("Start time: ", stime);
    console.log("(main) DutchAuction's Mint price: ", await dutch.calculatePrice());


    // console.log(await ethers.Signer.isSigner(eth_accounts[0]));

    // await virtualUser(provider, dutch, eth_accounts[0]);
    // await virtualUser(provider, dutch, eth_accounts[1]);

    ts = await dutch.TOTAL_SUPPLY();
    console.log("Total supply: ", ts);
    while (true) {
        mc = await dutch.mintCount();
        if (mc == ts) {
            break;
        } else {
            for (let i = 0; i < eth_accounts.length; i++) {
                await delay(100);
                await virtualUser(provider, dutch, eth_accounts[i]);
                // let estimatedGas = await provider.getFeeData();
                // console.log("lastBaseFeePerGas:", estimatedGas.lastBaseFeePerGas);
            }
        }
    }

    console.log("##### End #####");
    // console.log(await provider.getBlockNumber())
    // let estimatedGas = await provider.getFeeData();
    // console.log("Estimated Gas:", estimatedGas);
}


main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });
